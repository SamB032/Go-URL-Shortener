
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>url-shortener: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/SamB032/Go-URL-Shortener/cmd/url-shortener/main.go (0.0%)</option>
				
				<option value="file1">github.com/SamB032/Go-URL-Shortener/internal/database/connection.go (100.0%)</option>
				
				<option value="file2">github.com/SamB032/Go-URL-Shortener/internal/database/query.go (100.0%)</option>
				
				<option value="file3">github.com/SamB032/Go-URL-Shortener/internal/httpServer/pages.go (0.0%)</option>
				
				<option value="file4">github.com/SamB032/Go-URL-Shortener/internal/httpServer/setup.go (0.0%)</option>
				
				<option value="file5">github.com/SamB032/Go-URL-Shortener/internal/shortKey/generator.go (100.0%)</option>
				
				<option value="file6">github.com/SamB032/Go-URL-Shortener/internal/validator/url.go (100.0%)</option>
				
				<option value="file7">github.com/SamB032/Go-URL-Shortener/mocks/mock_db_interface.go (22.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "log/slog"
        "os"
        "strings"

        database "github.com/SamB032/Go-URL-Shortener/internal/database"
        server "github.com/SamB032/Go-URL-Shortener/internal/httpServer"
)

type EnvironmentVariables struct {
        ServerPort       string
        LoggingLevel     string
        PostgresHost     string
        PostgresPort     string
        PostgresPassword string
        PostgresUser     string
        PostgresDBName   string
        TemplatesDir     string
}

func getEnvironmentVariables() *EnvironmentVariables <span class="cov0" title="0">{
        return &amp;EnvironmentVariables{
                ServerPort:       os.Getenv("SERVER_PORT"),
                LoggingLevel:     os.Getenv("LOGGING_LEVEL"),
                PostgresHost:     os.Getenv("POSTGRES_HOST"),
                PostgresPort:     os.Getenv("POSTGRES_PORT"),
                PostgresUser:     os.Getenv("POSTGRES_USER"),
                PostgresPassword: os.Getenv("POSTGRES_PASSWORD"),
                PostgresDBName:   os.Getenv("POSTGRES_DB"),
                TemplatesDir:     os.Getenv("TEMPLATES_DIR"),
        }
}</span>

func setupLogger(loggingLevel string) *slog.Logger <span class="cov0" title="0">{
        if len(loggingLevel) == 0 </span><span class="cov0" title="0">{
                loggingLevel = "INFO"
        }</span>

        // Convert the LOGGING_LEVEL to uppercase to make it case-insensitive
        <span class="cov0" title="0">level := strings.ToUpper(loggingLevel)

        // Set the appropriate log level based on the environment variable
        var logLevel slog.Level
        switch level </span>{
        case "DEBUG":<span class="cov0" title="0">
                logLevel = slog.LevelDebug</span>
        case "INFO":<span class="cov0" title="0">
                logLevel = slog.LevelInfo</span>
        case "WARN":<span class="cov0" title="0">
                logLevel = slog.LevelWarn</span>
        case "ERROR":<span class="cov0" title="0">
                logLevel = slog.LevelError</span>
        default:<span class="cov0" title="0">
                // Default to INFO if the LOGGING_LEVEL is invalid
                logLevel = slog.LevelInfo</span>
        }

        <span class="cov0" title="0">return slog.New(slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{
                Level: logLevel,
        }))</span>
}

func main() <span class="cov0" title="0">{
        environmentVariables := getEnvironmentVariables()

        // Initialise Logger
        logger := setupLogger(environmentVariables.LoggingLevel)

        // Initialise Database
        database := database.ConnectToDatabase(
                environmentVariables.PostgresHost,
                environmentVariables.PostgresPort,
                environmentVariables.PostgresUser,
                environmentVariables.PostgresPassword,
                environmentVariables.PostgresDBName,
                logger,
        )
        if database == nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>

        // Start server
        <span class="cov0" title="0">server := server.NewServer(
                environmentVariables.ServerPort,
                logger,
                database,
                environmentVariables.TemplatesDir,
        )

        err := server.Start(environmentVariables.ServerPort)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to start HTTP server",
                        slog.String("serverPort", environmentVariables.ServerPort),
                        slog.String("error", err.Error()),
                )
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package database

import (
        _ "github.com/lib/pq"

        "database/sql"
        "fmt"
        "log/slog"
)

var SqlOpen = sql.Open

type DBInterface interface {
        CheckShortkeyExists(shortKey string) (bool, error)
        CheckIfURLExists(url string) (bool, error)
        AddRecord(oldurl string, shortKey string) error
        FindURLUsingShortkey(shortKey string) (string, error)
        FindShortkeyUsingURL(url string) (string, error)
}

type Connection struct {
        Connection *sql.DB
}

func NewConnection(db *sql.DB, logger *slog.Logger, host, dbname string) *Connection <span class="cov8" title="1">{
        if err := db.Ping(); err != nil </span><span class="cov8" title="1">{
                logger.Error("Failed to ping database",
                        slog.String("host", host),
                        slog.String("DBName", dbname),
                        slog.String("Error", err.Error()),
                )
                db.Close()
                return nil
        }</span>

        <span class="cov8" title="1">logger.Info("Successfully connected to the database",
                slog.String("host", host),
                slog.String("DBName", dbname),
        )

        return &amp;Connection{Connection: db}</span>
}

func ConnectToDatabase(pgHost, pgPort, pgUser, pgPassword, pgName string, logger *slog.Logger) *Connection <span class="cov8" title="1">{
        psqlInfo := fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=disable",
                pgHost, pgPort, pgUser, pgPassword, pgName)

        db, err := SqlOpen("postgres", psqlInfo)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("Failed to open connection",
                        slog.String("Error", err.Error()),
                )
                return nil
        }</span>

        <span class="cov8" title="1">return NewConnection(db, logger, pgHost, pgName)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package database

import (
        _ "github.com/lib/pq"

        "fmt"
        "time"
)

// Checks whether a shortkey already exists in the database
func (db *Connection) CheckShortkeyExists(shortKey string) (bool, error) <span class="cov8" title="1">{
        query := `SELECT EXISTS(SELECT 1 FROM url WHERE shortkey = $1)`

        var exists bool
        err := db.Connection.QueryRow(query, shortKey).Scan(&amp;exists)
        if err != nil </span><span class="cov8" title="1">{
                return false, fmt.Errorf("error executing query: %v", err)
        }</span>
        <span class="cov8" title="1">return exists, nil</span>
}

// Check whether a URL already exists in the database
func (db *Connection) CheckIfURLExists(url string) (bool, error) <span class="cov8" title="1">{
        query := `SELECT EXISTS(SELECT 1 from URL where old_url = $1)`

        var exists bool
        err := db.Connection.QueryRow(query, url).Scan(&amp;exists)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>
        <span class="cov8" title="1">return exists, nil</span>
}

// Adds a mapping shortkey &lt;-&gt; url to the database
func (db *Connection) AddRecord(oldurl string, shortKey string) error <span class="cov8" title="1">{
        timestamp := time.Now() //Record timestamp of when record is added

        _, err := db.Connection.Exec(`INSERT INTO url (created_at, old_url, shortkey) VALUES ($1, $2, $3)`, timestamp, oldurl, shortKey)

        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Find the corresponding short url when given a shortKey
func (db *Connection) FindURLUsingShortkey(shortKey string) (string, error) <span class="cov8" title="1">{
        var oldURL string

        query := "SELECT old_url FROM url WHERE shortkey = $1"
        err := db.Connection.QueryRow(query, shortKey).Scan(&amp;oldURL)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">return oldURL, nil</span>
}

// Find shortkey when given the url
func (db *Connection) FindShortkeyUsingURL(url string) (string, error) <span class="cov8" title="1">{
        var shortKey string

        query := "SELECT shortkey FROM url WHERE old_url = $1"
        err := db.Connection.QueryRow(query, url).Scan(&amp;shortKey)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">return shortKey, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package urlServer

import (
        "html/template"
        "log/slog"
        "net/http"
        "strings"

        shortkey "github.com/SamB032/Go-URL-Shortener/internal/shortKey"
        validate "github.com/SamB032/Go-URL-Shortener/internal/validator"
)

// Serve the main index page
func (s *Server) indexPage(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        s.logger.Debug("Received HTTP request",
                slog.String("url", "/"),
                slog.String("Method", request.Method),
                slog.String("Address", request.RemoteAddr),
        )
        http.ServeFile(writer, request, s.templatesDir + "index.html")
}</span>

// Handle the form submit in the page
func (s *Server) formSubmit(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        s.logger.Debug("Received HTTP request",
                slog.String("url", "/CreateShortUrl"),
                slog.String("Method", request.Method),
                slog.String("Address", request.RemoteAddr),
        )

        if request.Method == http.MethodPost </span><span class="cov0" title="0">{
                // Check that the request can be parsed
                err := request.ParseForm()
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Debug("Unable to process form submit",
                                slog.String("url", "/CreateShortUrl"),
                                slog.String("Address", request.RemoteAddr),
                                slog.Int("StatusCode", http.StatusBadRequest),
                                slog.String("Error", err.Error()),
                        )
                        http.Error(writer, "Unable to process form", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov0" title="0">oldurl := request.FormValue("enteredURL")

                //Valite the input to see if its in a form of a url
                valid, exists, err := validate.ValidateURL(oldurl, s.database)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Error validating url input",
                                slog.String("enteredURL", oldurl),
                                slog.String("Error", err.Error()),
                                slog.Int("StatusCode", http.StatusInternalServerError),
                        )
                }</span>

                <span class="cov0" title="0">if !valid </span><span class="cov0" title="0">{
                        s.logger.Debug("Input is not in form of url",
                                slog.String("enteredURL", oldurl),
                                slog.Int("StatusCode", http.StatusBadRequest),
                        )
                        http.Error(writer, "Input is not in form a of a url", http.StatusBadRequest)
                        return
                }</span>

                <span class="cov0" title="0">var shortKey string
                if exists </span><span class="cov0" title="0">{
                        //Query the database to get the shortkey if one already exsits
                        shortKey, err = s.database.FindShortkeyUsingURL(oldurl)
                        if err != nil </span><span class="cov0" title="0">{
                                s.logger.Error("Error finding shortended url",
                                        slog.String("oldurl", oldurl),
                                        slog.String("Error", err.Error()),
                                        slog.Int("StatusCode", http.StatusInternalServerError),
                                )
                                http.Error(writer, "Error finding the shortened url", http.StatusInternalServerError)
                                return
                        }</span>
                } else<span class="cov0" title="0"> {
                        shortKey, err = shortkey.CreateShortKey(s.database) //Generate new shortkey

                        if err != nil </span><span class="cov0" title="0">{
                                s.logger.Error("Unable to generate shortkey",
                                        slog.String("Error", err.Error()),
                                )
                                http.Error(writer, "Unable to generate shortkey", http.StatusInternalServerError)
                                return
                        }</span>

                        //Add record to database
                        <span class="cov0" title="0">err = s.database.AddRecord(oldurl, shortKey)

                        if err != nil </span><span class="cov0" title="0">{
                                s.logger.Error("Unable to write record to database",
                                        slog.String("oldUrl", oldurl),
                                        slog.String("shortKey", shortKey),
                                        slog.String("Error", err.Error()),
                                        slog.Int("StatusCode", http.StatusInternalServerError),
                                )
                                http.Error(writer, "Unable to write record to database", http.StatusInternalServerError)
                                return
                        }</span>
                }

                // Create a struct with the form data to pass to the template
                <span class="cov0" title="0">type FormData struct {
                        GetURL string
                        NewURL string
                }
                data := FormData{
                        GetURL: s.redirectURL,
                        NewURL: shortKey,
                }

                // Open the newurl html file and use it as a template
                tmpl, err := template.ParseFiles(s.templatesDir + "newurl.html")
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Unable to parse template",
                                slog.String("template", s.templatesDir + "newurl.html"),
                                slog.String("Error", err.Error()),
                                slog.Int("StatusCode", http.StatusInternalServerError),
                        )
                        http.Error(writer, "Unable to load template", http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">err = tmpl.Execute(writer, data)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("Error executing template",
                                slog.String("Error", err.Error()),
                                slog.Int("StatusCode", http.StatusInternalServerError),
                        )
                        http.Error(writer, "Unable to render template", http.StatusInternalServerError)
                        return
                }</span>

                // Log that page loading was a success
                <span class="cov0" title="0">s.logger.Debug("Page rendering success",
                        slog.String("url", "/CreateShortUrl"),
                        slog.String("Method", request.Method),
                        slog.String("Address", request.RemoteAddr),
                )</span>
        } else<span class="cov0" title="0"> {
                s.logger.Debug("Method not supported",
                        slog.String("Mehod", request.Method),
                        slog.String("url", "/CreateShortUrl"),
                )
                http.Error(writer, "Only POST method is supported", http.StatusMethodNotAllowed)
        }</span>
}

// User provides a short key and redirect them to the corresponding url
func (s *Server) shortKeyHandler(writer http.ResponseWriter, request *http.Request) <span class="cov0" title="0">{
        // Extract the shortkey from the URL
        parts := strings.Split(request.URL.Path, "/")
        if len(parts) &lt; 3 </span><span class="cov0" title="0">{
                s.logger.Debug("Short Key not provided",
                        slog.Int("StatusCode", http.StatusBadRequest),
                )
                http.Error(writer, "Shortkey not provided", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">shortKey := parts[2] // Get the shortkey from the URL
        // Process the shortkey by searching the database

        oldurl, err := s.database.FindURLUsingShortkey(shortKey)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Debug("Could not find corresponding url",
                        slog.String("shortKey", shortKey),
                        slog.String("Error", err.Error()),
                        slog.Int("StatusCode", http.StatusBadRequest),
                )
                http.Error(writer, "Could not find corresponding url", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">s.logger.Debug("Found corresponding url",
                slog.String("shortkey", shortKey),
                slog.String("url", oldurl),
        )

        //Redict the user to the new url
        http.Redirect(writer, request, oldurl, http.StatusFound)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package urlServer

import (
        "fmt"
        "log/slog"
        "net/http"

        database "github.com/SamB032/Go-URL-Shortener/internal/database"
)

type Server struct {
        logger         *slog.Logger
        database       database.DBInterface
        redirectURL    string
        templatesDir   string
        mux            *http.ServeMux
}

func NewServer(serverPort string, logger *slog.Logger, db database.DBInterface, templatesDir string) *Server <span class="cov0" title="0">{
        mux := http.NewServeMux()

        server := &amp;Server{
                logger:         logger,
                database:       db,
                redirectURL:    fmt.Sprintf("localhost:%s/sk/", serverPort),
                templatesDir:   templatesDir,
                mux:            mux,
        }

        mux.HandleFunc("/", server.indexPage)
        mux.HandleFunc("/CreateShortUrl", server.formSubmit)
        mux.HandleFunc("/sk/", server.shortKeyHandler)

        return server
}</span>

func (s *Server) Start(serverPort string) error <span class="cov0" title="0">{
        return http.ListenAndServe(fmt.Sprintf(":%s", serverPort), s.mux)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package shortkey

import (
        "math/rand"

        database "github.com/SamB032/Go-URL-Shortener/internal/database"
)

const URL_CHARSET = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
const URL_LENGTH = 5

// Generate a shortkey, return only if one is found that does not already exists
func CreateShortKey(dbConnection database.DBInterface) (string, error) <span class="cov8" title="1">{
        var newurl string
        for </span><span class="cov8" title="1">{
                newurl = GenerateShortKey()
                exists, err := dbConnection.CheckShortkeyExists(newurl)
                if err != nil </span><span class="cov8" title="1">{
                        return "", err
                }</span> else<span class="cov8" title="1"> if !exists </span><span class="cov8" title="1">{
                        return newurl, nil
                }</span>
        }
}

// Generates a random key of URL_LENGTH and contains URL_CHARSET
func GenerateShortKey() string <span class="cov8" title="1">{
        shortKey := make([]byte, URL_LENGTH)

        for i := range shortKey </span><span class="cov8" title="1">{
                shortKey[i] = URL_CHARSET[rand.Intn(len(URL_CHARSET))]
        }</span>

        <span class="cov8" title="1">return string(shortKey)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package validate

import (
        "regexp"

        database "github.com/SamB032/Go-URL-Shortener/internal/database"
)

const urlRegex = `(?i)(https?://(?:www\.)?[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9]\.[^\s]{2,}|https?://(?:www\.)?[a-zA-Z0-9]+\.[^\s]{2,}|www\.[a-zA-Z0-9]+\.[^\s]{2,})`

// Checks if the input string is in the form of a URL, this also performs a database call to check if url already exists
func ValidateURL(url string, db database.DBInterface) (bool, bool, error) <span class="cov8" title="1">{
        exists, err := db.CheckIfURLExists(url)
        if err != nil </span><span class="cov8" title="1">{
                return false, false, err
        }</span>
        <span class="cov8" title="1">if exists </span><span class="cov8" title="1">{
                return true, true, nil
        }</span>

        // Regular expression to match URLs with or without schemes and with sub-directories
        <span class="cov8" title="1">re := regexp.MustCompile(urlRegex)

        // Return true if the url is valid
        return len(url) &lt;= 255 &amp;&amp; re.MatchString(url), false, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Code generated by mockery v2.53.0. DO NOT EDIT.

package mocks

import mock "github.com/stretchr/testify/mock"

// MockDbinterface is an autogenerated mock type for the DBInterface type
type MockDbinterface struct {
        mock.Mock
}

type MockDbinterface_Expecter struct {
        mock *mock.Mock
}

func (_m *MockDbinterface) EXPECT() *MockDbinterface_Expecter <span class="cov0" title="0">{
        return &amp;MockDbinterface_Expecter{mock: &amp;_m.Mock}
}</span>

// AddRecord provides a mock function with given fields: oldurl, shortKey
func (_m *MockDbinterface) AddRecord(oldurl string, shortKey string) error <span class="cov0" title="0">{
        ret := _m.Called(oldurl, shortKey)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for AddRecord")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(string, string) error); ok </span><span class="cov0" title="0">{
                r0 = rf(oldurl, shortKey)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// MockDbinterface_AddRecord_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddRecord'
type MockDbinterface_AddRecord_Call struct {
        *mock.Call
}

// AddRecord is a helper method to define mock.On call
//   - oldurl string
//   - shortKey string
func (_e *MockDbinterface_Expecter) AddRecord(oldurl interface{}, shortKey interface{}) *MockDbinterface_AddRecord_Call <span class="cov0" title="0">{
        return &amp;MockDbinterface_AddRecord_Call{Call: _e.mock.On("AddRecord", oldurl, shortKey)}
}</span>

func (_c *MockDbinterface_AddRecord_Call) Run(run func(oldurl string, shortKey string)) *MockDbinterface_AddRecord_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string), args[1].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockDbinterface_AddRecord_Call) Return(_a0 error) *MockDbinterface_AddRecord_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockDbinterface_AddRecord_Call) RunAndReturn(run func(string, string) error) *MockDbinterface_AddRecord_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// CheckIfURLExists provides a mock function with given fields: url
func (_m *MockDbinterface) CheckIfURLExists(url string) (bool, error) <span class="cov8" title="1">{
        ret := _m.Called(url)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CheckIfURLExists")</span>
        }

        <span class="cov8" title="1">var r0 bool
        var r1 error
        if rf, ok := ret.Get(0).(func(string) (bool, error)); ok </span><span class="cov0" title="0">{
                return rf(url)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(string) bool); ok </span><span class="cov0" title="0">{
                r0 = rf(url)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(bool)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(url)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// MockDbinterface_CheckIfURLExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckIfURLExists'
type MockDbinterface_CheckIfURLExists_Call struct {
        *mock.Call
}

// CheckIfURLExists is a helper method to define mock.On call
//   - url string
func (_e *MockDbinterface_Expecter) CheckIfURLExists(url interface{}) *MockDbinterface_CheckIfURLExists_Call <span class="cov0" title="0">{
        return &amp;MockDbinterface_CheckIfURLExists_Call{Call: _e.mock.On("CheckIfURLExists", url)}
}</span>

func (_c *MockDbinterface_CheckIfURLExists_Call) Run(run func(url string)) *MockDbinterface_CheckIfURLExists_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockDbinterface_CheckIfURLExists_Call) Return(_a0 bool, _a1 error) *MockDbinterface_CheckIfURLExists_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockDbinterface_CheckIfURLExists_Call) RunAndReturn(run func(string) (bool, error)) *MockDbinterface_CheckIfURLExists_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// CheckShortkeyExists provides a mock function with given fields: shortKey
func (_m *MockDbinterface) CheckShortkeyExists(shortKey string) (bool, error) <span class="cov8" title="1">{
        ret := _m.Called(shortKey)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CheckShortkeyExists")</span>
        }

        <span class="cov8" title="1">var r0 bool
        var r1 error
        if rf, ok := ret.Get(0).(func(string) (bool, error)); ok </span><span class="cov0" title="0">{
                return rf(shortKey)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(string) bool); ok </span><span class="cov0" title="0">{
                r0 = rf(shortKey)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(bool)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(shortKey)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// MockDbinterface_CheckShortkeyExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckShortkeyExists'
type MockDbinterface_CheckShortkeyExists_Call struct {
        *mock.Call
}

// CheckShortkeyExists is a helper method to define mock.On call
//   - shortKey string
func (_e *MockDbinterface_Expecter) CheckShortkeyExists(shortKey interface{}) *MockDbinterface_CheckShortkeyExists_Call <span class="cov0" title="0">{
        return &amp;MockDbinterface_CheckShortkeyExists_Call{Call: _e.mock.On("CheckShortkeyExists", shortKey)}
}</span>

func (_c *MockDbinterface_CheckShortkeyExists_Call) Run(run func(shortKey string)) *MockDbinterface_CheckShortkeyExists_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockDbinterface_CheckShortkeyExists_Call) Return(_a0 bool, _a1 error) *MockDbinterface_CheckShortkeyExists_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockDbinterface_CheckShortkeyExists_Call) RunAndReturn(run func(string) (bool, error)) *MockDbinterface_CheckShortkeyExists_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// FindShortkeyUsingURL provides a mock function with given fields: url
func (_m *MockDbinterface) FindShortkeyUsingURL(url string) (string, error) <span class="cov0" title="0">{
        ret := _m.Called(url)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for FindShortkeyUsingURL")</span>
        }

        <span class="cov0" title="0">var r0 string
        var r1 error
        if rf, ok := ret.Get(0).(func(string) (string, error)); ok </span><span class="cov0" title="0">{
                return rf(url)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(string) string); ok </span><span class="cov0" title="0">{
                r0 = rf(url)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(string)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(url)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockDbinterface_FindShortkeyUsingURL_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindShortkeyUsingURL'
type MockDbinterface_FindShortkeyUsingURL_Call struct {
        *mock.Call
}

// FindShortkeyUsingURL is a helper method to define mock.On call
//   - url string
func (_e *MockDbinterface_Expecter) FindShortkeyUsingURL(url interface{}) *MockDbinterface_FindShortkeyUsingURL_Call <span class="cov0" title="0">{
        return &amp;MockDbinterface_FindShortkeyUsingURL_Call{Call: _e.mock.On("FindShortkeyUsingURL", url)}
}</span>

func (_c *MockDbinterface_FindShortkeyUsingURL_Call) Run(run func(url string)) *MockDbinterface_FindShortkeyUsingURL_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockDbinterface_FindShortkeyUsingURL_Call) Return(_a0 string, _a1 error) *MockDbinterface_FindShortkeyUsingURL_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockDbinterface_FindShortkeyUsingURL_Call) RunAndReturn(run func(string) (string, error)) *MockDbinterface_FindShortkeyUsingURL_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// FindURLUsingShortkey provides a mock function with given fields: shortKey
func (_m *MockDbinterface) FindURLUsingShortkey(shortKey string) (string, error) <span class="cov0" title="0">{
        ret := _m.Called(shortKey)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for FindURLUsingShortkey")</span>
        }

        <span class="cov0" title="0">var r0 string
        var r1 error
        if rf, ok := ret.Get(0).(func(string) (string, error)); ok </span><span class="cov0" title="0">{
                return rf(shortKey)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(string) string); ok </span><span class="cov0" title="0">{
                r0 = rf(shortKey)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(string)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(shortKey)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockDbinterface_FindURLUsingShortkey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindURLUsingShortkey'
type MockDbinterface_FindURLUsingShortkey_Call struct {
        *mock.Call
}

// FindURLUsingShortkey is a helper method to define mock.On call
//   - shortKey string
func (_e *MockDbinterface_Expecter) FindURLUsingShortkey(shortKey interface{}) *MockDbinterface_FindURLUsingShortkey_Call <span class="cov0" title="0">{
        return &amp;MockDbinterface_FindURLUsingShortkey_Call{Call: _e.mock.On("FindURLUsingShortkey", shortKey)}
}</span>

func (_c *MockDbinterface_FindURLUsingShortkey_Call) Run(run func(shortKey string)) *MockDbinterface_FindURLUsingShortkey_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockDbinterface_FindURLUsingShortkey_Call) Return(_a0 string, _a1 error) *MockDbinterface_FindURLUsingShortkey_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockDbinterface_FindURLUsingShortkey_Call) RunAndReturn(run func(string) (string, error)) *MockDbinterface_FindURLUsingShortkey_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockDbinterface creates a new instance of MockDbinterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockDbinterface(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockDbinterface <span class="cov8" title="1">{
        mock := &amp;MockDbinterface{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov8" title="1">{ mock.AssertExpectations(t) }</span>)

        <span class="cov8" title="1">return mock</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
